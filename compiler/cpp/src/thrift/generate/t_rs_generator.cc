/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <string>
#include <fstream>
#include <iostream>

#include "thrift/platform.h"
#include "thrift/version.h"
#include "thrift/generate/t_generator.h"

using std::ofstream;
using std::ostringstream;
using std::string;
using std::vector;

static const string endl = "\n"; // avoid ostream << std::endl flushes

// IMPORTANT: by default generator functions include extra endlines!

class t_rs_generator : public t_generator {
public:
  t_rs_generator(
    t_program* program,
    const std::map<std::string, std::string>& parsed_options,
    const std::string& options
  ) : t_generator(program) {
    gen_dir_ = get_out_dir();
  }

  /**
   * Init and close methods
   */

  void init_generator();
  void close_generator();

  /**
   * Program-level generation functions
   */

  void generate_typedef(t_typedef* ttypedef);
  void generate_enum(t_enum* tenum);
  void generate_const(t_const* tconst);
  void generate_struct(t_struct* tstruct);
  void generate_xception(t_struct* txception);
  void generate_service(t_service* tservice);

private:
  // Directory to which generated code is written.
  string gen_dir_;

  // File to which generated code is written.
  std::ofstream f_gen_;

  // Create the autogenerated comment at the top of each generated file.
  string autogen_comment();

  // Write the rust representation of a thrift struct to the generated file.
  void render_rust_struct(t_struct* tstruct);

  // Write the rust representation of a thrift enum to the generated file.
  void render_rust_union(t_struct* tstruct);

  // Return a string representing the rust type given a `t_type`.
  string t_type_to_rust_type(t_type* ttype);

  // Return a string representing the rift `protocol::TFieldType` given a `t_type`.
  string t_type_to_rust_field_type_enum(t_type* ttype);

  // Return the trait name for the sync service client given a `t_service` name.
  string rust_sync_client_trait_name(t_service* tservice);

  // Return a string containing all the unpacked service call args
  // given a service call function `t_function`.
  // If `is_declaration` is `true` we prepend the args with `&mut self`
  // and include the arg types in the returned string. If `false` we omit
  // the `self` qualifier and only use the arg names.
  string rust_sync_client_call_args(t_function* tfunc, bool is_declaration);

  // Return `true` if the rust type can be passed by value, `false` otherwise.
  bool can_t_type_be_passed_by_value(t_type* ttype);

  // Return `true` if this struct field is optional and needs to be wrapped
  // by an `Option<TYPE_NAME>`, `false` otherwise.
  bool is_field_optional(t_field* tfield);

  bool does_service_call_have_args(t_function* tfunc);

  string render_rust_map(t_map* tmap);
  string render_rust_set(t_set* tset);
  string render_rust_list(t_list* tlist);
  string wrap_with_req_qualifier(const string& rust_type, t_field::e_req req);
  string render_namespaced_rust_type(t_type* ttype);
  void render_rust_protocol_field_write(const string& field_prefix, t_field* tfield);
  void render_rust_const_value(t_const_value* tconstvalue);
  void render_rust_sync_client(t_service* tservice);
  void render_rust_sync_server(t_service* tservice);
  void render_rust_protocol_write(const string& prefix, t_field* tfield);
  void render_rust_sync_send_recv_wrapper(t_function* tfunc);
  void render_rust_sync_send(t_function* tfunc);
  void render_rust_sync_recv(t_function* tfunc);
};

// TODO: ensure errors handled properly

void t_rs_generator::init_generator() {
  // make output directory for this thrift program
  MKDIR(gen_dir_.c_str());

  // create the file into which we're going to write the generated code
  string f_gen_name = gen_dir_ + "/" + underscore(get_program()->get_name()) + ".rs";
  f_gen_.open(f_gen_name.c_str());

  // write the header comment
  f_gen_ << autogen_comment();

  // turn off some warnings
  f_gen_ << "#![allow(unused_imports)]" << endl; // I always include BTreeMap/BTreeSet
  f_gen_ << "#![allow(non_snake_case)]" << endl; // I keep the user-defined names (should I change to underscore?)
  f_gen_ << endl;

  // add standard includes
  f_gen_ << "extern crate rift;" << endl;
  f_gen_ << endl;
  f_gen_ << "use std::collections::{BTreeMap, BTreeSet};" << endl;
  f_gen_ << endl;
  f_gen_ << "use rift::{Error, Result};" << endl;
  f_gen_ << "use rift::protocol::{TFieldIdentifier, TFieldType, TMessageIdentifier, TMessageType, TProtocol, TStructIdentifier};" << endl;
  f_gen_ << endl;

  // add thrift includes
  const vector<t_program*> includes = get_program()->get_includes();
  if (!includes.empty()) {
    vector<t_program*>::const_iterator includes_iter;
    for(includes_iter = includes.begin(); includes_iter != includes.end(); ++includes_iter) {
      f_gen_ << "pub use " << underscore((*includes_iter)->get_name()) << ";" << endl;
    }
    f_gen_ << endl;
  }
}

string t_rs_generator::autogen_comment() {
  return std::string("") +
  "// " + autogen_summary() + "\n" +
  "// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n" +
  "\n";
}

void t_rs_generator::close_generator() {
  f_gen_.close();
}

void t_rs_generator::generate_typedef(t_typedef* ttypedef) {
  std::string actual_type = t_type_to_rust_type(ttypedef->get_type());
  f_gen_ << "type " << ttypedef->get_symbolic() << " = " << actual_type << ";" << endl;
  f_gen_ << endl;
}

void t_rs_generator::generate_enum(t_enum* tenum) {
  // enum definition
  f_gen_ << "#[derive(Copy, Clone, Debug, PartialEq)]" << endl;
  f_gen_ << "pub enum " << tenum->get_name() << " {" << endl;

  indent_up();
  vector<t_enum_value*> constants = tenum->get_constants();
  vector<t_enum_value*>::iterator constants_iter;
  for (constants_iter = constants.begin(); constants_iter != constants.end(); ++constants_iter) {
    f_gen_ << indent() << (*constants_iter)-> get_name() << " = " << (*constants_iter)->get_value() << "," << endl;
  }

  indent_down();
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // let x = Foo::Bar as u32;
  // int -> enum reverse matching
  // TODO: avoid double loops
}

void t_rs_generator::generate_const(t_const* tconst) {
  /*
  f_gen_
    << "const " << tconst->get_name() << ": " << t_type_to_rust_type(tconst->get_type())
    << " = 1" << ";" // FIXME: WTF is going on with constants?!
    << endl;
  f_gen_ << endl;
  */
}

void t_rs_generator::render_rust_const_value(t_const_value* tconstvalue) {

}

void t_rs_generator::generate_struct(t_struct* tstruct) {
  if (tstruct->is_struct()) {
    render_rust_struct(tstruct);
  } else if (tstruct->is_union()) {
    render_rust_union(tstruct);
  } else {
    throw "cannot generate struct for exception";
  }
}

void t_rs_generator::render_rust_struct(t_struct* tstruct) {
  // struct comment demarcation
  f_gen_ << "//" << endl;
  f_gen_ << "// " << tstruct->get_name() << endl;
  f_gen_ << "//" << endl;
  f_gen_ << endl;

  // struct
  f_gen_ << "#[derive(Debug, PartialEq)]" << endl;
  f_gen_ << "pub struct " << tstruct->get_name() << " {" << endl;
  vector<t_field*> members = tstruct->get_sorted_members();
  if (!members.empty()) {
    indent_up();
    vector<t_field*>::iterator members_iter;
    for(members_iter = members.begin(); members_iter != members.end(); ++members_iter) {
      t_field* tfield = (*members_iter);
      t_field::e_req req = tfield->get_req();
      f_gen_
        << indent()
        << tfield->get_name() << ": " << wrap_with_req_qualifier(t_type_to_rust_type(tfield->get_type()), req) << ","
        << endl;
    }
    indent_down();
  }
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // struct impl
  f_gen_ << "impl " << tstruct->get_name() << " {" << endl;
  indent_up();

  f_gen_
    << indent()
    << "pub fn write_to_protocol<O: TProtocol>(&self, o_prot: &mut O) -> Result<()> {"
    << endl;
  indent_up();

  // write struct header to output protocol
  f_gen_
    << indent()
    << "let struct_ident = TStructIdentifier { name: \"" + tstruct->get_name() + "\".to_owned() };"
    << endl;
  f_gen_
    << indent()
    << "try!(o_prot.write_struct_begin(&struct_ident));"
    << endl;

  // write struct members to output protocol
  if (!members.empty()) {
    vector<t_field*>::iterator members_iter;
    for(members_iter = members.begin(); members_iter != members.end(); ++members_iter) {
      t_field* tfield = (*members_iter);
      render_rust_protocol_write("self", tfield);
    }
  }

  // write struct footer to output protocol
  f_gen_ << indent() << "try!(o_prot.write_struct_end());" << endl;
  f_gen_ << indent() << "Ok(())" << endl;
  indent_down();
  f_gen_ << indent() << "}" << endl;

  //f_gen_ << endl;

  // read struct fields from the input protocol
  /*
  f_gen_ << indent() << "pub fn readStruct<P: TProtocol>(i_prot: P) -> Result<" << name << "> {" << endl;
  indent_up();
  f_gen_ << indent() << "Ok(())" << endl;
  indent_down();
  f_gen_ << indent() << "}" << endl;
  */

  indent_down();
  f_gen_ << "}" << endl;
  f_gen_ << endl;
}

string t_rs_generator::render_namespaced_rust_type(t_type* ttype) {
  if (ttype->is_enum() || ttype->is_struct() || ttype->is_typedef()) {
    string type_namespace = ttype->get_program()->get_name();
    if (type_namespace != get_program()->get_name()) {
      return type_namespace + "::" + ttype->get_name();
    } else {
      return ttype->get_name();
    }
  }

  throw "Unsupported namespaced type " + ttype->get_name();
}

string t_rs_generator::wrap_with_req_qualifier(const string& rust_type, t_field::e_req req) {
  switch(req) {
  case t_field::T_REQUIRED:
    return rust_type;
  case t_field::T_OPTIONAL:
    return "Option<" + rust_type + ">";
  case t_field::T_OPT_IN_REQ_OUT:
    return "Option<" + rust_type + ">";
  }
}

void t_rs_generator::render_rust_protocol_write(const string& prefix, t_field* tfield) {
  string field_prefix = "";
  if (!prefix.empty()) {
    field_prefix = prefix + ".";
  }

  ostringstream field_stream;
  field_stream
    << "let field_ident = TFieldIdentifier {"
    << "name: Some(\"" << tfield->get_name() << "\".to_owned()" << "), "
    << "field_type: " << t_type_to_rust_field_type_enum(tfield->get_type()) << ", "
    << "id: " << tfield->get_key() << " "
    << "};";
  string field_ident_string = field_stream.str();

  if (tfield->get_req() == t_field::T_OPTIONAL || tfield->get_req() == t_field::T_OPT_IN_REQ_OUT) {
    string field_name = field_prefix + tfield->get_name();
    f_gen_ << indent() << "if " << field_name << ".is_some() {" << endl;
    indent_up();
    f_gen_ << indent() << field_ident_string << endl;
    f_gen_ << indent() << "try!(o_prot.write_field_begin(&field_ident));" << endl;
    render_rust_protocol_field_write(field_prefix, tfield);
    f_gen_ << indent() << "try!(o_prot.write_field_end());" << endl;
    f_gen_ << indent() << "()" << endl;
    indent_down();
    f_gen_ << indent() << "} else {" << endl;
    indent_up();
    if (tfield->get_req() == t_field::T_OPT_IN_REQ_OUT) {
      f_gen_ << indent() << field_ident_string << endl;
      f_gen_ << indent() << "try!(o_prot.write_field_begin(&field_ident));" << endl;
      f_gen_ << indent() << "try!(o_prot.write_field_end());" << endl;
    }
    f_gen_ << indent() << "()" << endl;
    indent_down();
    f_gen_ << indent() << "}" << endl;
  } else {
    render_rust_protocol_field_write(field_prefix, tfield);
  }
}
void t_rs_generator::render_rust_protocol_field_write(const string& field_prefix, t_field* tfield) {
  bool optional;
  if (tfield->get_req() == t_field::T_OPTIONAL || tfield->get_req() == t_field::T_OPT_IN_REQ_OUT) {
    optional = true;
  } else {
    optional = false;
  }

  t_type* ttype = tfield->get_type();

  string field_name;
  if (optional) {
    if (ttype->is_base_type() && !ttype->is_string()) {
      field_name = field_prefix + tfield->get_name() + ".unwrap()";
    } else {
      field_name = field_prefix + tfield->get_name() + ".as_ref().unwrap()";
    }
  } else {
    field_name = field_prefix + tfield->get_name();
  }

  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_VOID:
      throw "Cannot write field of type TYPE_VOID to output protocol";
    case t_base_type::TYPE_STRING:
      f_gen_ << indent() << "try!(o_prot.write_string(&" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_BOOL:
      f_gen_ << indent() << "try!(o_prot.write_bool(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_I8:
      f_gen_ << indent() << "try!(o_prot.write_i8(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_I16:
      f_gen_ << indent() << "try!(o_prot.write_i16(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_I32:
      f_gen_ << indent() << "try!(o_prot.write_i32(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_I64:
      f_gen_ << indent() << "try!(o_prot.write_i64(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_DOUBLE:
      f_gen_ << indent() << "try!(o_prot.write_double(" + field_name + "));" << endl;
      return;
    }
  } else if (ttype->is_enum()) {
    return;
  } else if (ttype->is_struct()) {
    f_gen_ << indent() << "try!(" << field_name << ".write_to_protocol(o_prot));" << endl;
    return;
  } else if (ttype->is_map()) {
    return;
  } else if (ttype->is_set()) {
    return;
  } else if (ttype->is_list()) {
    return;
  }

  throw "Unsupported type " + ttype->get_name();
}

void t_rs_generator::render_rust_union(t_struct* tstruct) {
}

string t_rs_generator::render_rust_map(t_map* tmap) {
  return "BTreeMap<" + t_type_to_rust_type(tmap->get_key_type()) + ", " + t_type_to_rust_type(tmap->get_val_type()) + ">";
}

string t_rs_generator::render_rust_set(t_set* tset) {
  return "BTreeSet<" + t_type_to_rust_type(tset->get_elem_type()) + ">";
}

string t_rs_generator::render_rust_list(t_list* tlist) {
  return "Vec<" + t_type_to_rust_type(tlist->get_elem_type()) + ">";
}

void t_rs_generator::generate_xception(t_struct* txception) {
  //render_rust_struct(txception);
}

void t_rs_generator::generate_service(t_service* tservice) {
  render_rust_sync_client(tservice);
  render_rust_sync_server(tservice);
}

void t_rs_generator::render_rust_sync_client(t_service* tservice) {
  string client_trait_name = rust_sync_client_trait_name(tservice);
  string client_impl_struct_name = "T" + tservice->get_name() + "SyncClient";

  string extension = "";
  if (tservice->get_extends() != NULL) {
    t_service* extends = tservice->get_extends();
    extension = " : " + extends->get_program()->get_namespace() + "::" + rust_sync_client_trait_name(extends);
  }

  const std::vector<t_function*> functions = tservice->get_functions();
  std::vector<t_function*>::const_iterator func_iter;

  // service comment demarcation
  f_gen_ << "//" << endl;
  f_gen_ << "// service " << tservice->get_name() << endl;
  f_gen_ << "//" << endl;
  f_gen_ << endl;

  // render the trait
  // although not strictly necessary, I'm doing this to make testing easier
  // this way users can pass in anything that implements the client facade
  f_gen_ << "pub trait " << client_trait_name << extension << " {" << endl;
  indent_up();
  for(func_iter = functions.begin(); func_iter != functions.end(); ++func_iter) {
    t_function* tfunc = (*func_iter);
    string func_name = tfunc->get_name();
    string func_args = rust_sync_client_call_args(tfunc, true);
    string func_return = t_type_to_rust_type(tfunc->get_returntype());
    f_gen_ << indent() << "fn " << func_name <<  func_args << " -> Result<" << func_return << ">;" << endl;
  }
  indent_down();
  f_gen_ << indent() << "}" << endl;
  f_gen_ << endl;

  // [sigh] this is annoying
  // to create a parameterized rust struct I have to declare the type parameters twice
  //
  // struct declaration:
  // struct HasFoo<I: Foo, O: Foo> {
  //     i_foo: I,
  //     o_foo: O,
  // }
  //
  // struct implementation:
  // impl<I: Foo, O: Foo> HasFoo<I, O> {
  //     // code goes here ...
  // }
  //
  // even more annoyingly, those bounds have to be added on *every* impl block for the struct

  // render the implementing struct
  f_gen_ << "pub struct " << client_impl_struct_name << "<I: TProtocol, O: TProtocol> {" << endl;
  indent_up();
  f_gen_ << indent() << "i_prot: I," << endl;
  f_gen_ << indent() << "o_prot: O," << endl;
  f_gen_ << indent() << "sequence_number: i32," << endl;
  indent_down();
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // render the struct implementation
  // this includes the new() function as well as the helper send/recv methods for each service call
  f_gen_ << "impl<I: TProtocol, O: TProtocol> " << client_impl_struct_name << "<I, O> {" << endl;
  indent_up();
  for(func_iter = functions.begin(); func_iter != functions.end(); ++func_iter) {
    t_function* tfunc = (*func_iter);
    render_rust_sync_send(tfunc);
    render_rust_sync_recv(tfunc);
  }
  indent_down();
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // render all the service methods for the implementing struct
  f_gen_ << "impl<I: TProtocol, O:TProtocol>" << client_trait_name << " for " << client_impl_struct_name << "<I, O> {" << endl;
  indent_up();
  for(func_iter = functions.begin(); func_iter != functions.end(); ++func_iter) {
    t_function* func = (*func_iter);
    render_rust_sync_send_recv_wrapper(func);
  }
  indent_down();
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // finally, thrift args for service calls are packed
  // into a struct that's transmitted over the wire, so
  // generate structs for those too
  for(func_iter = functions.begin(); func_iter != functions.end(); ++func_iter) {
    t_function* func = (*func_iter);
    render_rust_struct(func->get_arglist());
  }
}

void t_rs_generator::render_rust_sync_send_recv_wrapper(t_function* tfunc) {
  string func_name = tfunc->get_name();
  string func_decl_args = rust_sync_client_call_args(tfunc, true);
  string func_call_args = rust_sync_client_call_args(tfunc, false);
  string func_return = t_type_to_rust_type(tfunc->get_returntype());

  f_gen_ << indent() << "fn " << func_name <<  func_decl_args << " -> Result<" << func_return << "> {" << endl;
  indent_up();
  f_gen_ << indent() << "try!(self.send_" << func_name << func_call_args << ");" << endl;
  f_gen_ << indent() << "self.recv_" << func_name << "()" << endl;
  indent_down();
  f_gen_ << indent() << "}" << endl;
}

void t_rs_generator::render_rust_sync_send(t_function* tfunc) {
  string func_name = "send_" + tfunc->get_name();
  string func_args = rust_sync_client_call_args(tfunc, true);

  // declaration
  f_gen_ << indent() << "fn " << func_name <<  func_args << " -> Result<()> {" << endl;
  indent_up();

  // increment the sequence number and generate the call header
  f_gen_ << indent() << "self.sequence_number = self.sequence_number + 1;" << endl;
  f_gen_
    << indent()
    << "let message_ident = "
    << "TMessageIdentifier { name:\"" << tfunc->get_name() << "\".to_owned(), "
    << "message_type: TMessageType::Call, "
    << "sequence_number: self.sequence_number };"
    << endl;
  // pack the arguments into the containing struct that we'll write out over the wire
  // note that this struct is generated even if we have 0 args
  ostringstream struct_definition;
  vector<t_field*> members = tfunc->get_arglist()->get_sorted_members();
  vector<t_field*>::iterator members_iter;
  for (members_iter = members.begin(); members_iter != members.end(); ++members_iter) {
    t_field* tfield = (*members_iter);
    struct_definition << tfield->get_name() << ": " << tfield->get_name() << ", ";
  }
  string struct_fields = struct_definition.str();
  if (struct_fields.size() > 0) {
    struct_fields = struct_fields.substr(0, struct_fields.size() - 2); // strip trailing comma
  }
  f_gen_
    << indent()
    << "let call_args = "
    << tfunc->get_arglist()->get_name()
    << " { "
    << struct_fields
    << " };"
    << endl;
  // write everything over the wire
  f_gen_ << indent() << "try!(self.o_prot.write_message_begin(&message_ident));" << endl;
  f_gen_ << indent() << "try!(call_args.write_to_protocol(&mut self.o_prot));" << endl; // written even if we have 0 args
  f_gen_ << indent() << "try!(self.o_prot.write_message_end());" << endl;
  f_gen_ << indent() << "Ok(())" << endl;
  indent_down();
  f_gen_ << indent() << "}" << endl;
}

void t_rs_generator::render_rust_sync_recv(t_function* tfunc) {
  string func_name = "recv_" + tfunc->get_name();
  string func_return = t_type_to_rust_type(tfunc->get_returntype());

  f_gen_ << indent() << "fn " << func_name << "(&mut self) -> Result<" << func_return << "> {" << endl;
  indent_up();
  indent_down();
  f_gen_ << indent() << "}" << endl;
}

string t_rs_generator::rust_sync_client_trait_name(t_service* tservice) {
  return "TAbstract" + tservice->get_name() + "SyncClient";
}

string t_rs_generator::rust_sync_client_call_args(t_function* tfunc, bool is_declaration) {
  ostringstream func_args;
  func_args << (is_declaration ? "(&mut self" : "(");

  // service call args are packed into a struct.
  // unpack them and expand into a valid rust function arg list.
  // types that can be passed by value are, and those that can't
  // will be prepended with '&' so that they can be passed by ref
  int is_first_arg = true;
  if (does_service_call_have_args(tfunc)) {
    t_struct* args = tfunc->get_arglist();
    std::vector<t_field*> fields = args->get_sorted_members();
    std::vector<t_field*>::iterator field_iter;
    for (field_iter = fields.begin(); field_iter != fields.end(); ++field_iter) {
      t_field* tfield = (*field_iter);
      string rust_type = t_type_to_rust_type(tfield->get_type());
      string tfield_string = (can_t_type_be_passed_by_value(tfield->get_type()) ? "" : "&") + rust_type;
      if (is_first_arg) { // FIXME: remove conditional
        if (is_declaration) {
          func_args << ", ";
        }
        is_first_arg = false;
      } else {
        func_args << ", ";
      }
      func_args << tfield->get_name() << (is_declaration ? ": " + tfield_string : "");
    }
  }

  func_args << ")";
  return func_args.str();
}

void t_rs_generator::render_rust_sync_server(t_service* tservice) {
}

bool t_rs_generator::does_service_call_have_args(t_function* tfunc) {
  return tfunc->get_arglist() != NULL && !tfunc->get_arglist()->get_sorted_members().empty();
}

bool t_rs_generator::is_field_optional(t_field* tfield) {
  return tfield->get_req() == t_field::T_OPTIONAL || tfield->get_req() == t_field::T_OPT_IN_REQ_OUT;
}

bool t_rs_generator::can_t_type_be_passed_by_value(t_type* ttype) {
  return ttype->is_base_type();
}

string t_rs_generator::t_type_to_rust_type(t_type* ttype) {
  ttype = get_true_type(ttype);
  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_VOID:
      return "()";
    case t_base_type::TYPE_STRING:
      return "String";
    case t_base_type::TYPE_BOOL:
      return "bool";
    case t_base_type::TYPE_I8:
      return "i8";
    case t_base_type::TYPE_I16:
      return "i16";
    case t_base_type::TYPE_I32:
      return "i32";
    case t_base_type::TYPE_I64:
      return "i64";
    case t_base_type::TYPE_DOUBLE:
      return "f64";
    }
  } else if (ttype->is_enum()) {
    return render_namespaced_rust_type(ttype);
  } else if (ttype->is_struct()) {
    return render_namespaced_rust_type(ttype);
  } else if (ttype->is_typedef()) {
    return render_namespaced_rust_type(ttype);
  } else if (ttype->is_map()) {
    return render_rust_map((t_map*)ttype);
  } else if (ttype->is_set()) {
    return render_rust_set((t_set*)ttype);
  } else if (ttype->is_list()) {
    return render_rust_list((t_list*)ttype);
  }

  throw "cannot find rust type for " + ttype->get_name();
}

string t_rs_generator::t_type_to_rust_field_type_enum(t_type* ttype) {
  ttype = get_true_type(ttype);
  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_VOID:
      throw "will not generate protocol::TFieldType for TYPE_VOID";
    case t_base_type::TYPE_STRING:
      return "TFieldType::String";
    case t_base_type::TYPE_BOOL:
      return "TFieldType::Bool";
    case t_base_type::TYPE_I8:
      return "TFieldType::I08";
    case t_base_type::TYPE_I16:
      return "TFieldType::I16";
    case t_base_type::TYPE_I32:
      return "TFieldType::I32";
    case t_base_type::TYPE_I64:
      return "TFieldType::I64";
    case t_base_type::TYPE_DOUBLE:
      return "TFieldType::Double";
    }
  } else if (ttype->is_enum()) {
    return "TFieldType::I32";
  } else if (ttype->is_struct() || ttype->is_xception()) {
    return "TFieldType::Struct";
  } else if (ttype->is_map()) {
    return "TFieldType::Map";
  } else if (ttype->is_set()) {
    return "TFieldType::Set";
  } else if (ttype->is_list()) {
    return "TFieldType::List";
  }

  throw "cannot find TFieldType for " + ttype->get_name();
}

THRIFT_REGISTER_GENERATOR(
  rs,
  "Rust",
  "   nodoc\n")
