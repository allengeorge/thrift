/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <string>
#include <fstream>
#include <iostream>

#include "thrift/platform.h"
#include "thrift/version.h"
#include "thrift/generate/t_generator.h"

using std::ofstream;
using std::string;
using std::vector;

static const string endl = "\n"; // avoid ostream << std::endl flushes

// IMPORTANT: by default generator functions include extra endlines!

class t_rs_generator : public t_generator {
public:
  t_rs_generator(
    t_program* program,
    const std::map<std::string, std::string>& parsed_options,
    const std::string& options
  ) : t_generator(program) {
    gen_code_dir_ = get_out_dir();
  }

  /**
   * Init and close methods
   */

  void init_generator();
  void close_generator();

  /**
   * Program-level generation functions
   */

  void generate_typedef(t_typedef* ttypedef);
  void generate_enum(t_enum* tenum);
  void generate_const(t_const* tconst);
  void generate_struct(t_struct* tstruct);
  void generate_xception(t_struct* txception);
  void generate_service(t_service* tservice);

private:
  // Directory to which generated code is written
  string gen_code_dir_;

  // file to which generated code is written
  std::ofstream f_gen_code_;

  // Create the autogenerated comment at the top of each thrift-generated file.
  string autogen_comment();

  // Create the autogenerated rust representation of a thrift struct.
  void render_rust_struct(t_struct* tstruct);

  // Create the autogenerated rust representation of a thrift union (should be an enum).
  void render_rust_union(t_struct* tstruct);

  // Return the rust string that
  string render_rust_type(t_type* ttype);

  string render_rust_map(t_map* tmap);
  string render_rust_set(t_set* tset);
  string render_rust_list(t_list* tlist);
  string wrap_with_req_qualifier(const string& rust_type, t_field::e_req req);
  string render_namespaced_rust_type(t_type* ttype);
  void render_rust_sync_service_client(t_service* tservice);
  void render_rust_sync_service_server(t_service* tservice);
};

// TODO: ensure errors handled properly

void t_rs_generator::init_generator() {
  // make output directory for this thrift program
  MKDIR(gen_code_dir_.c_str());

  // create the file into which we're going to write the generated code
  string f_gen_code_name = gen_code_dir_ + "/" + underscore(get_program()->get_name()) + ".rs";
  f_gen_code_.open(f_gen_code_name.c_str());

  // write the header comment
  f_gen_code_ << autogen_comment();

  // turn off some warnings
  f_gen_code_ << "#![allow(unused_imports)]" << endl; // I always include BTreeMap/BTreeSet
  f_gen_code_ << "#![allow(non_snake_case)]" << endl; // I keep the user-defined names (should I change to underscore?)
  f_gen_code_ << endl;

  // add standard includes
  f_gen_code_ << "extern crate rift;" << endl;
  f_gen_code_ << endl;
  f_gen_code_ << "use std::collections::{BTreeMap, BTreeSet};" << endl;
  f_gen_code_ << endl;
  f_gen_code_ << "use rift::{Error, Result};" << endl;
  f_gen_code_ << "use rift::protocol::{TFieldIdentifier, TMessageIdentifier, TProtocol, TStructIdentifier};" << endl;
  f_gen_code_ << endl;

  // add thrift includes
  const vector<t_program*> includes = get_program()->get_includes();
  if (!includes.empty()) {
    vector<t_program*>::const_iterator includes_iter;
    for(includes_iter = includes.begin(); includes_iter != includes.end(); ++includes_iter) {
      f_gen_code_ << "pub use " << underscore((*includes_iter)->get_name()) << ";" << endl;
    }
    f_gen_code_ << endl;
  }
}

string t_rs_generator::autogen_comment() {
  return std::string("") +
  "// " + autogen_summary() + "\n" +
  "// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n" +
  "\n";
}

void t_rs_generator::close_generator() {
  f_gen_code_.close();
}

void t_rs_generator::generate_typedef(t_typedef* ttypedef) {
  std::string actual_type = render_rust_type(ttypedef->get_type());
  f_gen_code_ << "type " << ttypedef->get_symbolic() << " = " << actual_type << ";" << endl;
  f_gen_code_ << endl;
}

void t_rs_generator::generate_enum(t_enum* tenum) {
  // enum definition
  f_gen_code_ << "#[derive(Copy, Clone, Debug, PartialEq)]" << endl;
  f_gen_code_ << "pub enum " << tenum->get_name() << " {" << endl;

  indent_up();
  vector<t_enum_value*> constants = tenum->get_constants();
  vector<t_enum_value*>::iterator constants_iter;
  for (constants_iter = constants.begin(); constants_iter != constants.end(); ++constants_iter) {
    f_gen_code_ << indent() << (*constants_iter)-> get_name() << " = " << (*constants_iter)->get_value() << "," << endl;
  }

  indent_down();
  f_gen_code_ << "}" << endl;
  f_gen_code_ << endl;

  // let x = Foo::Bar as u32;
  // int -> enum reverse matching
  // TODO: avoid double loops
}

void t_rs_generator::generate_const(t_const* tconst) {
  /*
  f_gen_code_
    << "const " << tconst->get_name() << ": " << render_rust_type(tconst->get_type())
    << " = 1" << ";" // FIXME: WTF is going on with constants?!
    << endl;
  f_gen_code_ << endl;
  */
}

void t_rs_generator::generate_struct(t_struct* tstruct) {
  if (tstruct->is_struct()) {
    render_rust_struct(tstruct);
  } else if (tstruct->is_union()) {
    render_rust_union(tstruct);
  } else {
    throw "cannot generate struct for exception";
  }
}

void t_rs_generator::render_rust_struct(t_struct* tstruct) {
  string name = tstruct->get_name();
  vector<t_field*> members = tstruct->get_sorted_members();

  // the struct itself
  f_gen_code_ << "#[derive(Debug, PartialEq)]" << endl;
  f_gen_code_ << "pub struct " << name << " {" << endl;
  if (!members.empty()) {
    indent_up();
    vector<t_field*>::iterator members_iter;
    for(members_iter = members.begin(); members_iter != members.end(); ++members_iter) {
      t_field* tfield = (*members_iter);
      t_type* ttype = get_true_type(tfield->get_type());
      t_field::e_req req = tfield->get_req();
      f_gen_code_
        << indent()
        << tfield->get_name() << ": " << wrap_with_req_qualifier(render_rust_type(ttype), req) << ","
        << endl;
    }
    indent_down();
  }
  f_gen_code_ << "}" << endl;
  f_gen_code_ << endl;

  // struct impl
  f_gen_code_ << "impl " << name << " {" << endl;
  indent_up();

  // write the serialization function
  f_gen_code_
    << indent()
    << "pub fn write_struct<P: TProtocol>(s: &" << name << ", out_prot: &mut P) -> Result<()> {"
    << endl;
  indent_up();

  // write struct header to output protocol
  f_gen_code_
    << indent()
    << "let struct_ident = TStructIdentifier { name: \"" + name + "\".to_owned() };"
    << endl;
  f_gen_code_
    << indent()
    << "try!(out_prot.write_struct_begin(&struct_ident));"
    << endl;

  // write struct members to output protocol
  if (!members.empty()) {
    f_gen_code_ << endl;
    vector<t_field*>::iterator members_iter;
    for(members_iter = members.begin(); members_iter != members.end(); ++members_iter) {
      t_field* tfield = (*members_iter);
      t_type* ttype = get_true_type(tfield->get_type());
      t_field::e_req req = tfield->get_req();
    }
  }

  // write struct footer to output protocol
  f_gen_code_ << indent() << "try!(out_prot.write_struct_end());" << endl;
  f_gen_code_ << indent() << "Ok(())" << endl;
  indent_down();
  f_gen_code_ << indent() << "}" << endl;

  //f_gen_code_ << endl;

  // read struct fields from the input protocol
  /*
  f_gen_code_ << indent() << "pub fn readStruct<P: TProtocol>(in_prot: P) -> Result<" << name << "> {" << endl;
  indent_up();
  f_gen_code_ << indent() << "Ok(())" << endl;
  indent_down();
  f_gen_code_ << indent() << "}" << endl;
  */

  indent_down();
  f_gen_code_ << "}" << endl;
  f_gen_code_ << endl;
}

string t_rs_generator::render_rust_type(t_type* ttype) {
  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_VOID:
      throw "void types not supported as struct member";
    case t_base_type::TYPE_STRING:
      return "String";
    case t_base_type::TYPE_BOOL:
      return "bool";
    case t_base_type::TYPE_I8:
      return "i8";
    case t_base_type::TYPE_I16:
      return "i16";
    case t_base_type::TYPE_I32:
      return "i32";
    case t_base_type::TYPE_I64:
      return "i64";
    case t_base_type::TYPE_DOUBLE:
      return "f64";
    }
  } else if (ttype->is_enum()) {
    return render_namespaced_rust_type(ttype);
  } else if (ttype->is_struct()) {
    return render_namespaced_rust_type(ttype);
  } else if (ttype->is_typedef()) {
    return render_namespaced_rust_type(ttype);
  } else if (ttype->is_map()) {
    return render_rust_map((t_map*)ttype);
  } else if (ttype->is_set()) {
    return render_rust_set((t_set*)ttype);
  } else if (ttype->is_list()) {
    return render_rust_list((t_list*)ttype);
  }

  throw "Unsupported type " + ttype->get_name();
}

string t_rs_generator::render_namespaced_rust_type(t_type* ttype) {
  if (ttype->is_enum() || ttype->is_struct() || ttype->is_typedef()) {
    string type_namespace = ttype->get_program()->get_name();
    if (type_namespace != get_program()->get_name()) {
      return type_namespace + "::" + ttype->get_name();
    } else {
      return ttype->get_name();
    }
  }

  throw "Unsupported namespaced type " + ttype->get_name();
}

string t_rs_generator::wrap_with_req_qualifier(const string& rust_type, t_field::e_req req) {
  switch(req) {
  case t_field::T_REQUIRED:
    return rust_type;
  case t_field::T_OPTIONAL:
    return "Option<" + rust_type + ">";
  case t_field::T_OPT_IN_REQ_OUT:
    return "Option<" + rust_type + ">";
  }
  throw "Unsupported e_req " + req;
}

void t_rs_generator::render_rust_union(t_struct* tstruct) {
}

string t_rs_generator::render_rust_map(t_map* tmap) {
  return "BTreeMap<" + render_rust_type(tmap->get_key_type()) + ", " + render_rust_type(tmap->get_val_type()) + ">";
}

string t_rs_generator::render_rust_set(t_set* tset) {
  return "BTreeSet<" + render_rust_type(tset->get_elem_type()) + ">";
}

string t_rs_generator::render_rust_list(t_list* tlist) {
  return "Vec<" + render_rust_type(tlist->get_elem_type()) + ">";
}

void t_rs_generator::generate_xception(t_struct* txception) {
  //render_rust_struct(txception);
}

void t_rs_generator::generate_service(t_service* tservice) {
  render_rust_sync_service_client(tservice);
  render_rust_sync_service_server(tservice);
}

void t_rs_generator::render_rust_sync_service_client(t_service* tservice) {
  string client_trait_name = "TAbstract" + tservice->get_name() + "SyncClient";
  string client_impl_struct_name = "T" + tservice->get_name() + "SyncClient";

  // render the trait
  // although not strictly necessary, I'm doing this to make testing easier
  // this way users can pass in anything that implements the client facade
  f_gen_code_ << "pub trait " << client_trait_name << " {" << endl;
  f_gen_code_ << "}" << endl;
  f_gen_code_ << endl;

  // render the implementing struct
  f_gen_code_ << "pub struct " << client_impl_struct_name << " {" << endl;
  f_gen_code_ << "}" << endl;
  f_gen_code_ << endl;

  // render the factory functions for the implementing struct
  f_gen_code_ << "impl " << client_impl_struct_name << " {" << endl;
  f_gen_code_ << "}" << endl;
  f_gen_code_ << endl;

  // now render all the service methods for the implementing struct
  f_gen_code_ << "impl " << client_trait_name << " for " << client_impl_struct_name << " {" << endl;
  f_gen_code_ << "}" << endl;
  f_gen_code_ << endl;
}

void t_rs_generator::render_rust_sync_service_server(t_service* tservice) {
}

THRIFT_REGISTER_GENERATOR(
  rs,
  "Rust",
  "   nodoc\n")
