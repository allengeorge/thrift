/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <string>
#include <fstream>
#include <iostream>

#include "thrift/platform.h"
#include "thrift/version.h"
#include "thrift/generate/t_generator.h"

using std::ofstream;
using std::ostringstream;
using std::string;
using std::vector;

static const string endl = "\n"; // avoid ostream << std::endl flushes

// IMPORTANT: by default generator functions include extra endlines!

class t_rs_generator : public t_generator {
public:
  t_rs_generator(
    t_program* program,
    const std::map<std::string, std::string>& parsed_options,
    const std::string& options
  ) : t_generator(program) {
    gen_dir_ = get_out_dir();
  }

  /**
   * Init and close methods
   */

  void init_generator();
  void close_generator();

  /**
   * Program-level generation functions
   */

  void generate_typedef(t_typedef* ttypedef);
  void generate_enum(t_enum* tenum);
  void generate_const(t_const* tconst);
  void generate_struct(t_struct* tstruct);
  void generate_xception(t_struct* txception);
  void generate_service(t_service* tservice);

private:
  // Directory to which generated code is written
  string gen_dir_;

  // file to which generated code is written
  std::ofstream f_gen_;

  // Create the autogenerated comment at the top of each thrift-generated file.
  string autogen_comment();

  // Create the autogenerated rust representation of a thrift struct.
  void render_rust_struct(t_struct* tstruct);

  // Create the autogenerated rust representation of a thrift union (should be an enum).
  void render_rust_union(t_struct* tstruct);

  // Return a string representing the rust type given a t_type.
  string t_type_to_rust_type(t_type* ttype);

  // Return a string representing the protocol::TFieldType given a t_type.
  string t_type_to_rust_field_type_enum(t_type* ttype);

  string render_rust_map(t_map* tmap);
  string render_rust_set(t_set* tset);
  string render_rust_list(t_list* tlist);
  string wrap_with_req_qualifier(const string& rust_type, t_field::e_req req);
  string render_namespaced_rust_type(t_type* ttype);
  void render_rust_sync_service_client(t_service* tservice);
  void render_rust_sync_service_server(t_service* tservice);
  void render_rust_protocol_write(const string& prefix, t_field* tfield);
  void render_rust_protocol_field_write(const string& field_prefix, t_field* tfield);
  void render_rust_const_value(t_const_value* tconstvalue);
};

// TODO: ensure errors handled properly

void t_rs_generator::init_generator() {
  // make output directory for this thrift program
  MKDIR(gen_dir_.c_str());

  // create the file into which we're going to write the generated code
  string f_gen_name = gen_dir_ + "/" + underscore(get_program()->get_name()) + ".rs";
  f_gen_.open(f_gen_name.c_str());

  // write the header comment
  f_gen_ << autogen_comment();

  // turn off some warnings
  f_gen_ << "#![allow(unused_imports)]" << endl; // I always include BTreeMap/BTreeSet
  f_gen_ << "#![allow(non_snake_case)]" << endl; // I keep the user-defined names (should I change to underscore?)
  f_gen_ << endl;

  // add standard includes
  f_gen_ << "extern crate rift;" << endl;
  f_gen_ << endl;
  f_gen_ << "use std::collections::{BTreeMap, BTreeSet};" << endl;
  f_gen_ << endl;
  f_gen_ << "use rift::{Error, Result};" << endl;
  f_gen_ << "use rift::protocol::{TFieldIdentifier, TFieldType, TMessageIdentifier, TProtocol, TStructIdentifier};" << endl;
  f_gen_ << endl;

  // add thrift includes
  const vector<t_program*> includes = get_program()->get_includes();
  if (!includes.empty()) {
    vector<t_program*>::const_iterator includes_iter;
    for(includes_iter = includes.begin(); includes_iter != includes.end(); ++includes_iter) {
      f_gen_ << "pub use " << underscore((*includes_iter)->get_name()) << ";" << endl;
    }
    f_gen_ << endl;
  }
}

string t_rs_generator::autogen_comment() {
  return std::string("") +
  "// " + autogen_summary() + "\n" +
  "// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n" +
  "\n";
}

void t_rs_generator::close_generator() {
  f_gen_.close();
}

void t_rs_generator::generate_typedef(t_typedef* ttypedef) {
  std::string actual_type = t_type_to_rust_type(ttypedef->get_type());
  f_gen_ << "type " << ttypedef->get_symbolic() << " = " << actual_type << ";" << endl;
  f_gen_ << endl;
}

void t_rs_generator::generate_enum(t_enum* tenum) {
  // enum definition
  f_gen_ << "#[derive(Copy, Clone, Debug, PartialEq)]" << endl;
  f_gen_ << "pub enum " << tenum->get_name() << " {" << endl;

  indent_up();
  vector<t_enum_value*> constants = tenum->get_constants();
  vector<t_enum_value*>::iterator constants_iter;
  for (constants_iter = constants.begin(); constants_iter != constants.end(); ++constants_iter) {
    f_gen_ << indent() << (*constants_iter)-> get_name() << " = " << (*constants_iter)->get_value() << "," << endl;
  }

  indent_down();
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // let x = Foo::Bar as u32;
  // int -> enum reverse matching
  // TODO: avoid double loops
}

void t_rs_generator::generate_const(t_const* tconst) {
  /*
  f_gen_
    << "const " << tconst->get_name() << ": " << t_type_to_rust_type(tconst->get_type())
    << " = 1" << ";" // FIXME: WTF is going on with constants?!
    << endl;
  f_gen_ << endl;
  */
}

void t_rs_generator::render_rust_const_value(t_const_value* tconstvalue) {

}

void t_rs_generator::generate_struct(t_struct* tstruct) {
  if (tstruct->is_struct()) {
    render_rust_struct(tstruct);
  } else if (tstruct->is_union()) {
    render_rust_union(tstruct);
  } else {
    throw "cannot generate struct for exception";
  }
}

void t_rs_generator::render_rust_struct(t_struct* tstruct) {
  vector<t_field*> members = tstruct->get_sorted_members();

  // struct
  f_gen_ << "#[derive(Debug, PartialEq)]" << endl;
  f_gen_ << "pub struct " << tstruct->get_name() << " {" << endl;
  if (!members.empty()) {
    indent_up();
    vector<t_field*>::iterator members_iter;
    for(members_iter = members.begin(); members_iter != members.end(); ++members_iter) {
      t_field* tfield = (*members_iter);
      t_type* ttype = get_true_type(tfield->get_type());
      t_field::e_req req = tfield->get_req();
      f_gen_
        << indent()
        << tfield->get_name() << ": " << wrap_with_req_qualifier(t_type_to_rust_type(ttype), req) << ","
        << endl;
    }
    indent_down();
  }
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // struct impl
  f_gen_ << "impl " << tstruct->get_name() << " {" << endl;
  indent_up();

  f_gen_
    << indent()
    << "pub fn write_to_protocol<P: TProtocol>(&self, out_prot: &mut P) -> Result<()> {"
    << endl;
  indent_up();

  // write struct header to output protocol
  f_gen_
    << indent()
    << "let struct_ident = TStructIdentifier { name: \"" + tstruct->get_name() + "\".to_owned() };"
    << endl;
  f_gen_
    << indent()
    << "try!(out_prot.write_struct_begin(&struct_ident));"
    << endl;

  // write struct members to output protocol
  if (!members.empty()) {
    vector<t_field*>::iterator members_iter;
    for(members_iter = members.begin(); members_iter != members.end(); ++members_iter) {
      t_field* tfield = (*members_iter);
      render_rust_protocol_write("self", tfield);
    }
  }

  // write struct footer to output protocol
  f_gen_ << indent() << "try!(out_prot.write_struct_end());" << endl;
  f_gen_ << indent() << "Ok(())" << endl;
  indent_down();
  f_gen_ << indent() << "}" << endl;

  //f_gen_ << endl;

  // read struct fields from the input protocol
  /*
  f_gen_ << indent() << "pub fn readStruct<P: TProtocol>(in_prot: P) -> Result<" << name << "> {" << endl;
  indent_up();
  f_gen_ << indent() << "Ok(())" << endl;
  indent_down();
  f_gen_ << indent() << "}" << endl;
  */

  indent_down();
  f_gen_ << "}" << endl;
  f_gen_ << endl;
}

string t_rs_generator::render_namespaced_rust_type(t_type* ttype) {
  if (ttype->is_enum() || ttype->is_struct() || ttype->is_typedef()) {
    string type_namespace = ttype->get_program()->get_name();
    if (type_namespace != get_program()->get_name()) {
      return type_namespace + "::" + ttype->get_name();
    } else {
      return ttype->get_name();
    }
  }

  throw "Unsupported namespaced type " + ttype->get_name();
}

string t_rs_generator::wrap_with_req_qualifier(const string& rust_type, t_field::e_req req) {
  switch(req) {
  case t_field::T_REQUIRED:
    return rust_type;
  case t_field::T_OPTIONAL:
    return "Option<" + rust_type + ">";
  case t_field::T_OPT_IN_REQ_OUT:
    return "Option<" + rust_type + ">";
  }
  throw "Unsupported e_req " + req;
}

void t_rs_generator::render_rust_protocol_write(const string& prefix, t_field* tfield) {
  string field_prefix = "";
  if (!prefix.empty()) {
    field_prefix = prefix + ".";
  }

  ostringstream field_stream;
  field_stream
    << "let field_ident = TFieldIdentifier {"
    << "name: Some(\"" << tfield->get_name() << "\".to_owned()" << "), "
    << "field_type: " << t_type_to_rust_field_type_enum(tfield->get_type()) << ", "
    << "id: " << tfield->get_key() << " "
    << "};";
  string field_ident_string = field_stream.str();

  if (tfield->get_req() == t_field::T_OPTIONAL || tfield->get_req() == t_field::T_OPT_IN_REQ_OUT) {
    string field_name = field_prefix + tfield->get_name();
    f_gen_ << indent() << "if " << field_name << ".is_some() {" << endl;
    indent_up();
    f_gen_ << indent() << field_ident_string << endl;
    f_gen_ << indent() << "try!(out_prot.write_field_begin(&field_ident));" << endl;
    render_rust_protocol_field_write(field_prefix, tfield);
    f_gen_ << indent() << "try!(out_prot.write_field_end());" << endl;
    f_gen_ << indent() << "()" << endl;
    indent_down();
    f_gen_ << indent() << "} else {" << endl;
    indent_up();
    if (tfield->get_req() == t_field::T_OPT_IN_REQ_OUT) {
      f_gen_ << indent() << field_ident_string << endl;
      f_gen_ << indent() << "try!(out_prot.write_field_begin(&field_ident));" << endl;
      f_gen_ << indent() << "try!(out_prot.write_field_end());" << endl;
    }
    f_gen_ << indent() << "()" << endl;
    indent_down();
    f_gen_ << indent() << "}" << endl;
  } else {
    render_rust_protocol_field_write(field_prefix, tfield);
  }
}
void t_rs_generator::render_rust_protocol_field_write(const string& field_prefix, t_field* tfield) {
  bool optional;
  if (tfield->get_req() == t_field::T_OPTIONAL || tfield->get_req() == t_field::T_OPT_IN_REQ_OUT) {
    optional = true;
  } else {
    optional = false;
  }

  t_type* ttype = tfield->get_type();

  string field_name;
  if (optional) {
    if (ttype->is_base_type() && !ttype->is_string()) {
      field_name = field_prefix + tfield->get_name() + ".unwrap()";
    } else {
      field_name = field_prefix + tfield->get_name() + ".as_ref().unwrap()";
    }
  } else {
    field_name = field_prefix + tfield->get_name();
  }

  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_STRING:
      f_gen_ << indent() << "try!(out_prot.write_string(&" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_BOOL:
      f_gen_ << indent() << "try!(out_prot.write_bool(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_I8:
      f_gen_ << indent() << "try!(out_prot.write_i8(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_I16:
      f_gen_ << indent() << "try!(out_prot.write_i16(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_I32:
      f_gen_ << indent() << "try!(out_prot.write_i32(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_I64:
      f_gen_ << indent() << "try!(out_prot.write_i64(" + field_name + "));" << endl;
      return;
    case t_base_type::TYPE_DOUBLE:
      f_gen_ << indent() << "try!(out_prot.write_double(" + field_name + "));" << endl;
      return;
    }
  } else if (ttype->is_enum()) {
    return;
  } else if (ttype->is_struct()) {
    f_gen_ << indent() << "try!(" << field_name << ".write_to_protocol(out_prot));" << endl;
    return;
  } else if (ttype->is_map()) {
    return;
  } else if (ttype->is_set()) {
    return;
  } else if (ttype->is_list()) {
    return;
  }

  throw "Unsupported type " + ttype->get_name();
}

void t_rs_generator::render_rust_union(t_struct* tstruct) {
}

string t_rs_generator::render_rust_map(t_map* tmap) {
  return "BTreeMap<" + t_type_to_rust_type(tmap->get_key_type()) + ", " + t_type_to_rust_type(tmap->get_val_type()) + ">";
}

string t_rs_generator::render_rust_set(t_set* tset) {
  return "BTreeSet<" + t_type_to_rust_type(tset->get_elem_type()) + ">";
}

string t_rs_generator::render_rust_list(t_list* tlist) {
  return "Vec<" + t_type_to_rust_type(tlist->get_elem_type()) + ">";
}

void t_rs_generator::generate_xception(t_struct* txception) {
  //render_rust_struct(txception);
}

void t_rs_generator::generate_service(t_service* tservice) {
  render_rust_sync_service_client(tservice);
  render_rust_sync_service_server(tservice);
}

void t_rs_generator::render_rust_sync_service_client(t_service* tservice) {
  string client_trait_name = "TAbstract" + tservice->get_name() + "SyncClient";
  string client_impl_struct_name = "T" + tservice->get_name() + "SyncClient";

  // render the trait
  // although not strictly necessary, I'm doing this to make testing easier
  // this way users can pass in anything that implements the client facade
  f_gen_ << "pub trait " << client_trait_name << " {" << endl;
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // render the implementing struct
  f_gen_ << "pub struct " << client_impl_struct_name << " {" << endl;
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // render the factory functions for the implementing struct
  f_gen_ << "impl " << client_impl_struct_name << " {" << endl;
  f_gen_ << "}" << endl;
  f_gen_ << endl;

  // now render all the service methods for the implementing struct
  f_gen_ << "impl " << client_trait_name << " for " << client_impl_struct_name << " {" << endl;
  f_gen_ << "}" << endl;
  f_gen_ << endl;
}

void t_rs_generator::render_rust_sync_service_server(t_service* tservice) {
}

string t_rs_generator::t_type_to_rust_type(t_type* ttype) {
  ttype = get_true_type(ttype);
  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_VOID:
      throw "will not generate rust type for TYPE_VOID";
    case t_base_type::TYPE_STRING:
      return "String";
    case t_base_type::TYPE_BOOL:
      return "bool";
    case t_base_type::TYPE_I8:
      return "i8";
    case t_base_type::TYPE_I16:
      return "i16";
    case t_base_type::TYPE_I32:
      return "i32";
    case t_base_type::TYPE_I64:
      return "i64";
    case t_base_type::TYPE_DOUBLE:
      return "f64";
    }
  } else if (ttype->is_enum()) {
    return render_namespaced_rust_type(ttype);
  } else if (ttype->is_struct()) {
    return render_namespaced_rust_type(ttype);
  } else if (ttype->is_typedef()) {
    return render_namespaced_rust_type(ttype);
  } else if (ttype->is_map()) {
    return render_rust_map((t_map*)ttype);
  } else if (ttype->is_set()) {
    return render_rust_set((t_set*)ttype);
  } else if (ttype->is_list()) {
    return render_rust_list((t_list*)ttype);
  }

  throw "cannot find rust type for " + ttype->get_name();
}

string t_rs_generator::t_type_to_rust_field_type_enum(t_type* ttype) {
  ttype = get_true_type(ttype);
  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_VOID:
      throw "will not generate protocol::TFieldType for TYPE_VOID";
    case t_base_type::TYPE_STRING:
      return "TFieldType::String";
    case t_base_type::TYPE_BOOL:
      return "TFieldType::Bool";
    case t_base_type::TYPE_I8:
      return "TFieldType::I08";
    case t_base_type::TYPE_I16:
      return "TFieldType::I16";
    case t_base_type::TYPE_I32:
      return "TFieldType::I32";
    case t_base_type::TYPE_I64:
      return "TFieldType::I64";
    case t_base_type::TYPE_DOUBLE:
      return "TFieldType::Double";
    }
  } else if (ttype->is_enum()) {
    return "TFieldType::I32";
  } else if (ttype->is_struct() || ttype->is_xception()) {
    return "TFieldType::Struct";
  } else if (ttype->is_map()) {
    return "TFieldType::Map";
  } else if (ttype->is_set()) {
    return "TFieldType::Set";
  } else if (ttype->is_list()) {
    return "TFieldType::List";
  }

  throw "cannot find TFieldType for " + ttype->get_name();
}

THRIFT_REGISTER_GENERATOR(
  rs,
  "Rust",
  "   nodoc\n")
