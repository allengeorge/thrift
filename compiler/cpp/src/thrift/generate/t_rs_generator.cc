/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <string>
#include <fstream>
#include <iostream>

#include "thrift/platform.h"
#include "thrift/version.h"
#include "thrift/generate/t_generator.h"

using std::ofstream;
using std::string;
using std::vector;

static const string endl = "\n"; // avoid ostream << std::endl flushes

// IMPORTANT: by default generator functions include extra endlines!

class t_rs_generator : public t_generator {
public:
    t_rs_generator(
        t_program* program,
        const std::map<std::string, std::string>& parsed_options,
        const std::string& options
    ) : t_generator(program) {
        gen_code_dir_ = get_out_dir();
    }

    /**
     * Init and close methods
     */

    void init_generator();
    void close_generator();

    /**
     * Program-level generation functions
     */

    void generate_typedef(t_typedef* ttypedef);
    void generate_enum(t_enum* tenum);
    void generate_const(t_const* tconst);
    void generate_struct(t_struct* tstruct);
    void generate_xception(t_struct* txception);
    void generate_service(t_service* tservice);

private:
    // Directory to which generated code is written
    string gen_code_dir_;

    // file to which generated code is written
    std::ofstream f_gen_code_;

    // Create the autogenerated comment at the top of each thrift-generated file.
    string autogen_comment();
};

// TODO: ensure errors handled properly

void t_rs_generator::init_generator() {
    // make output directory for this thrift program
    MKDIR(gen_code_dir_.c_str());

    // create the file into which we're going to write the generated code
    string f_gen_code_name = gen_code_dir_ + "/" + underscore(get_program()->get_name()) + ".rs";
    f_gen_code_.open(f_gen_code_name.c_str());
    f_gen_code_ << autogen_comment();

    // add standard includes
    f_gen_code_ << "extern crate rift;" << endl;
    f_gen_code_ << endl;
}

string t_rs_generator::autogen_comment() {
  return std::string("") +
    "// " + autogen_summary() + "\n" +
    "// DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING\n" +
    "\n";
}

void t_rs_generator::close_generator() {
    f_gen_code_.close();
}

void t_rs_generator::generate_typedef(t_typedef* ttypedef) {
    //std::string actual_name = ttypedef ->get_type()->get_name(); // FIXME: has to actually be namespaced;
    //f_types_ << "type " << ttypedef->get_symbolic() << " = " << actual_name << endl;
}

// TODO: handle values and mapping (?)
void t_rs_generator::generate_enum(t_enum* tenum) {
    // actual enum struct
    f_gen_code_ << "#[derive(Copy, Clone, Debug)]" << endl;
    f_gen_code_ << "pub enum " << tenum->get_name() << " {" << endl;

    indent_up();
    vector<t_enum_value*> constants = tenum->get_constants();
    vector<t_enum_value*>::iterator constants_iter;
    for (constants_iter = constants.begin(); constants_iter != constants.end(); ++constants_iter) {
        f_gen_code_ << indent() << (*constants_iter)-> get_name() << " = " << (*constants_iter)->get_value() << "," << endl;
    }

    indent_down();
    f_gen_code_ << "}" << endl << endl;

    // let x = Foo::Bar as u32;
}

void t_rs_generator::generate_const(t_const* tconst) {

}

void t_rs_generator::generate_struct(t_struct* tstruct) {

}

void t_rs_generator::generate_xception(t_struct* txception) {

}

void t_rs_generator::generate_service(t_service* t_service) {

}

THRIFT_REGISTER_GENERATOR(
    rs,
    "Rust",
    "   nodoc\n")
