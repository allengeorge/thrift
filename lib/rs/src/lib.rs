// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the License for the
// specific language governing permissions and limitations
// under the License.

//! Rift: Thrift implementation library for Rust.
//!
//! This crate provides implementations for the layers
//! required to build a working Thrift server and client.
//! It is divided into the following modules:
//! 1. errors
//! 2. protocol
//! 3. transport
//! 4. server
//!
//! Please see each module for detailed information on that module.
//!
//! At a high level these modules are layered as shown below,
//! with the app code generated by the Thrift compiler and exposing
//! a high-level interface using the error and result types
//! defined in this crate.
//!
//! ```text
//! +-----------+
//! |    app    | <-> errors/results
//! +-----------+
//! |  protocol |
//! +-----------+
//! | transport |
//! +-----------+
//! ```

#![crate_type = "lib"]

extern crate byteorder;
extern crate try_from;

#[macro_use]
extern crate log;

pub mod protocol;
pub mod server;
pub mod transport;

mod errors;
pub use errors::*;

/// Result type returned by all rift functions.
/// As is convention, this is a typedef of `std::result::Result`
/// with `E` defined as the rift `Error` type.
pub type Result<T> = std::result::Result<T, self::Error>;

pub fn verify_expected_sequence_number(expected: i32, actual: i32) -> Result<()> {
    if expected == actual {
        Ok(())
    } else {
        Err(
            Error::Application(
                ApplicationError {
                    kind: ApplicationErrorKind::BadSequenceId,
                    message: format!("expected {} got {}", expected, actual)
                }
            )
        )
    }
}

pub fn verify_expected_service_call(expected: &str, actual: &str) -> Result<()> {
    if expected == actual {
        Ok(())
    } else {
        Err(
            Error::Application(
                ApplicationError {
                    kind: ApplicationErrorKind::WrongMethodName,
                    message: format!("expected {} got {}", expected, actual)
                }
            )
        )
    }
}

pub fn verify_expected_message_type(expected: protocol::TMessageType, actual: protocol::TMessageType) -> Result<()> {
    if expected == actual {
        Ok(())
    } else {
        Err(
            Error::Application(
                ApplicationError {
                    kind: ApplicationErrorKind::InvalidMessageType,
                    message: format!("expected {} got {}", expected, actual)
                }
            )
        )
    }
}

pub fn verify_required_field_exists<T>(field_name: &str, field: &Option<T>) -> Result<()> {
    match *field {
        Some(_) => Ok(()),
        None => Err(
            Error::Protocol(
                ProtocolError {
                    kind: ProtocolErrorKind::Unknown,
                    message: format!("missing required field {}", field_name)
                }
            )
        ),
    }
}

pub fn field_id(field_ident: &protocol::TFieldIdentifier) -> self::Result<i16> {
    field_ident.id.ok_or(
        Error::Protocol(
            ProtocolError {
                kind: ProtocolErrorKind::Unknown,
                message: format!("missing field in in {:?}", field_ident)
            }
        )
    )
}
